<div id="container">
<div id="main">
		<div id="subNav">
			<h3 onclick="test_alert()">遺伝的アルゴリズム</h3>
			<p>試行錯誤を繰り返して解を求めるアルゴリズム</p>
			<p>生物の進化過程では，ある世代を形成している個体の集合の中で環境に適応した個体が高い確率で生き残り，次の世代に子を残す．このメカニズムをモデル化し，環境に対して最もよく適応した個体，すなわち目的関数に対して最適値を与えるような解を求める。</p>
		</div>
		<a href="/">戻る</a>　　<a href="/que_knn">演習</a>　	　<a href="/">ホーム</a>
</div><!-- /main -->
<hr>
<div id="code" class="codes">
<div id="editor" class="avoid-clicks" style="width:450px; height: 1200px"><b>//データ</b>
<span>ナップザック容量=15</span>
<span>入れ物=[a,b,c,d,e]</span>
	<span>重さ=[12,2,1, 4,1]</span>
	<span>価値=[ 4,2,1,10,2]</span>
<b>//目的</b>
//<span>ナップザック内の価値が高くなる入れ物リストを求める</span>

<b>//処理</b>
//個体の初期設定
リスト数 = 4，入れ物数 = 5;
//リスト[i][j]:i番目リストのj番目の欄
for(i=0;i&lt;リスト数;i++){
    for(j=0;j&lt;入れ物数;j++){
        リスト[i][j] = 入れる or 入れない;
    };
};

//操作を指定回繰り返す
繰り返し世代数 = 20;
for(g=0;g&lt;繰り返し世代数;g++){
    // 評価
    for(i=0;i&lt;リスト数;i++){
        for(j=0;j&lt;入れ物数;j++){
            if(リスト[i][j] == 入れる){
            　　リスト[i]の総重量 += 重さ[j];
            　　リスト[i]の総価値 += 価値[j];
            };
        };
        if(リスト[i]の総重量>ナップザック容量){
            リスト[i]の総価値 = 0;
        };
    };
    // 選択 エリート選択・ルーレット選択参照
    親リストの決定

    //交叉(一定確率)
    for(２組ずつ選びその回数繰り返す(今はx=0,2とする)){
        交叉確率 = 1〜100のどれか;
        if(交叉確率&lt;95){
            //交叉範囲(start〜end)の染色体を入れ替える
            start = 0〜(入れ物の数-1)のどれか;
            end = start〜(入れ物の数-1)のどれか
            for(i=0;i&lt;入れ物の数;i++){
                if(start&lt;=i &amp;&amp; i&lt;=end){
                    子供[0][i] = 親リスト[x+1][i];
                    子供[1][i] = 親リスト[x][i];
                }else{
                    子供[0][i] = 親リスト[x][i];
                    子供[1][i] = 親リスト[x+1][i];
                };
            };
            //子供を子供世代に入れる
                子供世代[x] = 子供[0];
                子供世代[x+1] = 子供[1];
            };
        }
        //突然変異
        for(i=0;i&lt;リスト数;i++){
            突然変異率 = 0〜100のどれか;
            if(突然変異率&lt;3){
                変更点 = ランダム;
                子供世代[i][変更点] = 入れる or 入れない;
            };
        };
    };
    //子供世代を親世代とする
    リスト=子供世代
};

最後の世代で総価値が最大のものが解となる

</div>
	<!--
	<p>
		<input type="button" value="ステップ" onClick="start()">
	</p>
	-->
<span id="code1"></span>
<span id="code2"></span>
<span id="code3">&emsp;&emsp;</span>
<span id="code4">&emsp;&emsp;</span>
<span id="code5">&emsp;&emsp;</span>
<span id="code6">&emsp;&emsp;</span>
<span id="code7">&emsp;</span>
<span id="code8"></span>
</div><!-- /code -->

<div id="anime">
	<img id="ga_nap_png" width="800" height="480" onclick="changeIMG();changeLINE();" src="/img/ga_nap/ga_nap.1.png">

</div><!-- /anime -->
<div id="sub">

</div><!-- /sub -->
</div><!-- /container -->
<hr>
<script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.2.0/ace.js"></script>
<!--<script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.2.0/ext-language_tools.js"></script>-->
<script>
  var editor = ace.edit("editor");
  editor.renderer.setShowGutter(false);
  //editor.$blockScrolling = Infinity;
  //editor.setOptions({
    //enableBasicAutocompletion: true,
    //enableSnippets: true,
    //_enableLiveAutocompletion: true
  //});
  editor.setTheme("ace/theme/monokai");
  editor.getSession().setMode("ace/mode/javascript");
</script>
<script src="/js/ga_nap.js" type="text/javascript" ></script>

# coding: utf-8
# 自分の得意な言語で
# Let's チャレンジ！！
input = raw_input().split()
L = int(input[0])
N = int(input[1])
M = int(input[2])
MAX = 2*N-1
a = [0]*M
b = [0]*M
c = [0]*M
for m in range(0,M):
    input = raw_input().split()
    a[m] = int(input[0])
    b[m] = int(input[1])
    c[m] = int(input[2])

def make(k):
    x = k
    if k == 2*N-1:
        x = 1
    return x
def returnK(k):
    x = k
    if k >= N:
        x = 2*N-1-k
    return x

for k in range(1,MAX):
    number = returnK(make(k))

def nextPoint(point,under,value):
    max = 0
    num = -1
    for m in range(0,M):
        if a[m] == point and value[m] < under and max < value[m]:
            max = value[m]
            num = m
    return num
p = [0]*MAX
p[0] = nextPoint(1,L)
print p[0]
answer = 1
for i in range(1,MAX):
    #1,2,3,4,5,6
    if i+1 < N:
        p[i] = nextPoint(i+1,c[p[i-1]],b[])
    else if i+1==N:
        p[i] = nextPoint(N-i,c[p[i-1]])
    else:
        p[i] = nextPoint(i,b[p[i-1]])
        
    print "number",number
    p[i] = nextPoint(number,c[p[i-1]])
    print p[i]
    if p[i] == -1:
        break
    answer = number
print answer
